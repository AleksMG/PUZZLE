<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PUZZLE | Correct Rotor Logic</title>
  <style>
    :root {
      --bg: #0f0f13;
      --fg: #e0e0ff;
      --accent: #4da6ff;
      --error: #ff6b6b;
      --card: #1a1a25;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', monospace;
    }
    body {
      background: var(--bg);
      color: var(--fg);
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      font-size: 1.8rem;
      color: var(--accent);
    }
    .card {
      background: var(--card);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }
    textarea, input {
      width: 100%;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      background: #111;
      color: var(--fg);
      font-family: monospace;
      font-size: 14px;
    }
    textarea {
      min-height: 80px;
      resize: vertical;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: var(--accent);
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    button:hover {
      opacity: 0.9;
    }
    button.decrypt {
      background: #ffaa4d;
    }
    button.copy {
      background: #7a7aff;
    }
    .output {
      margin-top: 15px;
      padding: 12px;
      background: #0a0a10;
      border-left: 3px solid var(--accent);
      white-space: pre-wrap;
      word-break: break-all;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 15px;
    }
    .stat-box {
      background: #0a0a10;
      padding: 12px;
      border-radius: 6px;
    }
    .error {
      color: var(--error);
      margin-top: 10px;
      font-weight: bold;
    }
    .alphabet-info {
      font-size: 0.9em;
      color: #aaa;
      margin-top: 4px;
    }
    .rotor-params {
      margin-top: 10px;
      padding: 12px;
      background: #0a0a10;
      border-radius: 6px;
      font-size: 0.85em;
      max-height: 400px;
      overflow-y: auto;
    }
    .rotor-line {
      margin: 4px 0;
      font-family: monospace;
    }
    .steps-line {
      margin: 2px 0;
      font-family: monospace;
      color: #4da6ff;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öôÔ∏è PUZZLE | Correct Rotor Logic</h1>

    <div class="card">
      <label for="alphabet">Alphabet (uppercase, no duplicates)</label>
      <input id="alphabet" type="text" 
             value="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             spellcheck="false" autocomplete="off">
      <div class="alphabet-info" id="alphabetInfo"></div>
    </div>

    <div class="card">
      <label for="key">Key (from alphabet)</label>
      <input id="key" type="text" value="SECRET" spellcheck="false" autocomplete="off">
      <div class="rotor-params" id="rotorParams">
        Rotor configurations will appear here
      </div>
    </div>

    <div class="card">
      <label for="plaintext">Plaintext</label>
      <textarea id="plaintext" spellcheck="false" autocomplete="off">AAAAAAAAAAAAAAAAAAAAAAAAAA</textarea>
      
      <div class="btn-group">
        <button id="encryptBtn">üîí Encrypt</button>
        <button class="decrypt" id="decryptBtn">üîì Decrypt</button>
        <button class="copy" id="copyBtn">üìã Copy</button>
      </div>
    </div>

    <div class="card">
      <label>Ciphertext</label>
      <div class="output" id="ciphertextOutput">[Result will appear here]</div>
    </div>

    <div class="card">
      <label>Analysis</label>
      <div class="stats">
        <div class="stat-box">Length: <span id="len">0</span></div>
        <div class="stat-box">Entropy: <span id="entropy">0.0000</span></div>
        <div class="stat-box">HEX: <span id="hex">‚Äî</span></div>
        <div class="stat-box">Base64: <span id="base64">‚Äî</span></div>
      </div>
    </div>

    <div id="error" class="error"></div>
  </div>

  <script>
    class CorrectRotorMachine {
      constructor(alphabetStr) {
        this.alphabet = alphabetStr.toUpperCase().split('');
        if (new Set(this.alphabet).size !== this.alphabet.length) {
          throw new Error("Alphabet has duplicates");
        }
        this.N = this.alphabet.length;
        this.charToIndex = new Map();
        for (let i = 0; i < this.N; i++) {
          this.charToIndex.set(this.alphabet[i], i);
        }
      }

      validateText(text) {
        for (const char of text) {
          if (!this.charToIndex.has(char)) {
            throw new Error(`Invalid char: '${char}'`);
          }
        }
      }

      buildRotorsAndSteps(key) {
        const keyArr = Array.from(key);
        const rotors = [];
        const steps = [];
        
        for (let r = 0; r < 10; r++) {
          const subkey = [];
          for (let i = 0; i < keyArr.length || i < 5; i++) {
            subkey.push(keyArr[(r * 7 + i) % keyArr.length]);
          }
          
          let seed = 0;
          for (let c of subkey.map(ch => this.charToIndex.get(ch))) {
            seed = (seed * 31 + c) & 0x7FFFFFFF;
          }
          
          let rotor = Array.from({length: this.N}, (_, i) => i);
          for (let i = this.N - 1; i > 0; i--) {
            seed = (seed * 1664525 + 1013904223) & 0x7FFFFFFF;
            const j = Math.floor((seed / 0x80000000) * (i + 1));
            [rotor[i], rotor[j]] = [rotor[j], rotor[i]];
          }
          rotors.push(rotor);
          
          // –®–∞–≥–∏: —Ç–æ–ª—å–∫–æ –Ω–µ—á—ë—Ç–Ω—ã–µ (–≤–∑–∞–∏–º–Ω–æ –ø—Ä–æ—Å—Ç—ã–µ —Å 26)
          const candidates = [1,3,5,7,9,11,15,17,19,21,23,25];
          const step = candidates[seed % candidates.length];
          steps.push(step);
        }
        
        return { rotors, steps };
      }

      forward(input, rotor, offset) {
        const rotatedInput = (input + offset) % this.N;
        const output = rotor[rotatedInput];
        return (output - offset + this.N) % this.N;
      }

      backward(output, rotor, offset) {
        const rotatedOutput = (output + offset) % this.N;
        const inputPos = rotor.indexOf(rotatedOutput);
        return (inputPos - offset + this.N) % this.N;
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –Ω–µ–ª–∏–Ω–µ–π–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
      getKeyParams(key) {
        const keyIndices = Array.from(key).map(c => this.charToIndex.get(c));
        const params = [];
        for (let i = 0; i < 10; i++) {
          let sum = 0;
          for (let j = 0; j < keyIndices.length; j++) {
            sum = (sum + keyIndices[j] * (i + j + 1)) & 0x7FFFFFFF;
          }
          params.push(sum % this.N);
        }
        return params;
      }

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π —Ä–æ—Ç–æ—Ä–æ–≤ (–ù–ï–õ–ò–ù–ï–ô–ù–û–ï)
      updatePositions(positions, keyParams, steps, position) {
        const count = (keyParams[0] + position) % 10 + 1; // 1-10 —Ä–æ—Ç–æ—Ä–æ–≤
        const start = (keyParams[1] + position) % 10;
        
        for (let i = 0; i < count; i++) {
          const rotorIndex = (start + i) % 10;
          positions[rotorIndex] = (positions[rotorIndex] + steps[rotorIndex]) % this.N;
        }
      }

      encrypt(plaintext, key) {
        plaintext = plaintext.toUpperCase();
        key = key.toUpperCase();
        this.validateText(plaintext);
        this.validateText(key);

        const { rotors, steps } = this.buildRotorsAndSteps(key);
        const keyParams = this.getKeyParams(key);
        let positions = new Array(10).fill(0); // –ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
        let ciphertext = '';

        for (let pos = 0; pos < plaintext.length; pos++) {
          // –®–ò–§–†–£–ï–ú —Å —Ç–µ–∫—É—â–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
          let signal = this.charToIndex.get(plaintext[pos]);
          for (let r = 0; r < 10; r++) {
            signal = this.forward(signal, rotors[r], positions[r]);
          }
          ciphertext += this.alphabet[signal];
          
          // –û–ë–ù–û–í–õ–Ø–ï–ú —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–û–°–õ–ï —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
          this.updatePositions(positions, keyParams, steps, pos);
        }

        return ciphertext;
      }

      decrypt(ciphertext, key) {
        key = key.toUpperCase();
        for (const c of ciphertext) {
          if (!this.charToIndex.has(c)) {
            throw new Error(`Invalid ciphertext char: '${c}'`);
          }
        }
        this.validateText(key);

        const { rotors, steps } = this.buildRotorsAndSteps(key);
        const keyParams = this.getKeyParams(key);
        let positions = new Array(10).fill(0); // –¢–û –ñ–ï –ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï!
        let plaintext = '';

        for (let pos = 0; pos < ciphertext.length; pos++) {
          // –î–ï–®–ò–§–†–£–ï–ú —Å —Ç–µ–º –∂–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º, —á—Ç–æ –±—ã–ª–æ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
          let signal = this.charToIndex.get(ciphertext[pos]);
          for (let r = 9; r >= 0; r--) {
            signal = this.backward(signal, rotors[r], positions[r]);
          }
          plaintext += this.alphabet[signal];
          
          // –û–ë–ù–û–í–õ–Ø–ï–ú —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–û–°–õ–ï –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (—Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ!)
          this.updatePositions(positions, keyParams, steps, pos);
        }

        return plaintext;
      }

      shannonEntropy(text) {
        if (!text) return 0;
        const freq = {};
        for (const c of text) {
          freq[c] = (freq[c] || 0) + 1;
        }
        let entropy = 0;
        const len = text.length;
        for (const count of Object.values(freq)) {
          const p = count / len;
          entropy -= p * Math.log2(p);
        }
        return entropy;
      }

      toHex(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
      }

      toBase64(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        return btoa(String.fromCharCode(...bytes));
      }
    }

    // UI
    const alphabetInput = document.getElementById('alphabet');
    const keyInput = document.getElementById('key');
    const plaintextInput = document.getElementById('plaintext');
    const ciphertextOutput = document.getElementById('ciphertextOutput');
    const encryptBtn = document.getElementById('encryptBtn');
    const decryptBtn = document.getElementById('decryptBtn');
    const copyBtn = document.getElementById('copyBtn');
    const errorDiv = document.getElementById('error');
    const alphabetInfo = document.getElementById('alphabetInfo');
    const rotorParams = document.getElementById('rotorParams');
    const lenEl = document.getElementById('len');
    const entropyEl = document.getElementById('entropy');
    const hexEl = document.getElementById('hex');
    const base64El = document.getElementById('base64');

    function showError(msg) {
      errorDiv.textContent = msg;
      setTimeout(() => errorDiv.textContent = '', 5000);
    }

    function updateAlphabetInfo() {
      const alphabet = alphabetInput.value.toUpperCase();
      const unique = [...new Set(alphabet.split(''))].join('');
      alphabetInfo.textContent = `Length: ${alphabet.length} | Unique: ${unique.length}`;
      if (alphabet.length !== unique.length) {
        alphabetInfo.style.color = 'var(--error)';
      } else {
        alphabetInfo.style.color = '#aaa';
      }
    }

    function updateRotorParams() {
      const alphabet = alphabetInput.value;
      const key = keyInput.value;
      if (!alphabet || !key) {
        rotorParams.innerHTML = 'Enter key to see rotors and steps';
        return;
      }

      try {
        const machine = new CorrectRotorMachine(alphabet);
        const { rotors, steps } = machine.buildRotorsAndSteps(key);
        let html = '';
        for (let i = 0; i < 10; i++) {
          const preview = rotors[i].map(idx => machine.alphabet[idx]).join('');
          html += `<div class="rotor-line"><strong>Rotor ${i}:</strong> ${preview}</div>`;
          html += `<div class="steps-line">Step ${i}: +${steps[i]}</div>`;
        }
        rotorParams.innerHTML = html;
      } catch (e) {
        rotorParams.innerHTML = '<div style="color:var(--error);">Invalid key/alphabet</div>';
      }
    }

    function updateAnalysis(text) {
      if (!text) {
        lenEl.textContent = '0';
        entropyEl.textContent = '0.0000';
        hexEl.textContent = '‚Äî';
        base64El.textContent = '‚Äî';
        return;
      }

      try {
        const cipher = new CorrectRotorMachine(alphabetInput.value);
        lenEl.textContent = text.length;
        entropyEl.textContent = cipher.shannonEntropy(text).toFixed(4);
        hexEl.textContent = cipher.toHex(text);
        base64El.textContent = cipher.toBase64(text);
      } catch (e) {
        hexEl.textContent = '‚Äî';
        base64El.textContent = '‚Äî';
      }
    }

    function encryptAction() {
      try {
        const cipher = new CorrectRotorMachine(alphabetInput.value);
        const result = cipher.encrypt(plaintextInput.value, keyInput.value);
        ciphertextOutput.textContent = result;
        updateAnalysis(result);
      } catch (e) {
        showError(e.message);
        ciphertextOutput.textContent = '[Error]';
        updateAnalysis('');
      }
    }

    function decryptAction() {
      try {
        const cipher = new CorrectRotorMachine(alphabetInput.value);
        const result = cipher.decrypt(plaintextInput.value, keyInput.value);
        ciphertextOutput.textContent = result;
        updateAnalysis(result);
      } catch (e) {
        showError(e.message);
        ciphertextOutput.textContent = '[Error]';
        updateAnalysis('');
      }
    }

    alphabetInput.addEventListener('input', () => {
      updateAlphabetInfo();
      updateRotorParams();
    });
    keyInput.addEventListener('input', updateRotorParams);
    encryptBtn.addEventListener('click', encryptAction);
    decryptBtn.addEventListener('click', decryptAction);
    copyBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(ciphertextOutput.textContent)
        .then(() => {}, () => showError("Failed to copy"));
    });

    updateAlphabetInfo();
    updateRotorParams();
  </script>
</body>
</html>
