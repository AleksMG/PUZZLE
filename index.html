<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Professional 10-Rotor Machine</title>
  <style>
    :root {
      --bg: #0f0f13;
      --fg: #e0e0ff;
      --accent: #4da6ff;
      --error: #ff6b6b;
      --card: #1a1a25;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', monospace;
    }
    body {
      background: var(--bg);
      color: var(--fg);
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      font-size: 1.8rem;
      color: var(--accent);
    }
    .card {
      background: var(--card);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }
    textarea, input {
      width: 100%;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      background: #111;
      color: var(--fg);
      font-family: monospace;
      font-size: 14px;
    }
    textarea {
      min-height: 80px;
      resize: vertical;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: var(--accent);
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    button:hover {
      opacity: 0.9;
    }
    button.decrypt {
      background: #ffaa4d;
    }
    button.copy {
      background: #7a7aff;
    }
    .output {
      margin-top: 15px;
      padding: 12px;
      background: #0a0a10;
      border-left: 3px solid var(--accent);
      white-space: pre-wrap;
      word-break: break-all;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 15px;
    }
    .stat-box {
      background: #0a0a10;
      padding: 12px;
      border-radius: 6px;
    }
    .error {
      color: var(--error);
      margin-top: 10px;
      font-weight: bold;
    }
    .alphabet-info {
      font-size: 0.9em;
      color: #aaa;
      margin-top: 4px;
    }
    .rotor-params {
      margin-top: 10px;
      padding: 12px;
      background: #0a0a10;
      border-radius: 6px;
      font-size: 0.85em;
      max-height: 400px;
      overflow-y: auto;
    }
    .rotor-line {
      margin: 4px 0;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öôÔ∏è Professional 10-Rotor Machine</h1>

    <div class="card">
      <label for="alphabet">Alphabet (uppercase, no duplicates)</label>
      <input id="alphabet" type="text" 
             value="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             spellcheck="false" autocomplete="off">
      <div class="alphabet-info" id="alphabetInfo"></div>
    </div>

    <div class="card">
      <label for="key">Key (from alphabet)</label>
      <input id="key" type="text" value="SECRET" spellcheck="false" autocomplete="off">
      <div class="rotor-params" id="rotorParams">
        Rotor configurations will appear here
      </div>
    </div>

    <div class="card">
      <label for="plaintext">Plaintext</label>
      <textarea id="plaintext" spellcheck="false" autocomplete="off">HELLO</textarea>
      
      <div class="btn-group">
        <button id="encryptBtn">üîí Encrypt</button>
        <button class="decrypt" id="decryptBtn">üîì Decrypt</button>
        <button class="copy" id="copyBtn">üìã Copy</button>
      </div>
    </div>

    <div class="card">
      <label>Ciphertext</label>
      <div class="output" id="ciphertextOutput">[Result will appear here]</div>
    </div>

    <div class="card">
      <label>Analysis</label>
      <div class="stats">
        <div class="stat-box">Length: <span id="len">0</span></div>
        <div class="stat-box">Entropy: <span id="entropy">0.00</span></div>
        <div class="stat-box">HEX: <span id="hex">‚Äî</span></div>
        <div class="stat-box">Base64: <span id="base64">‚Äî</span></div>
      </div>
    </div>

    <div id="error" class="error"></div>
  </div>

  <script>
    class ProfessionalRotorMachine {
      constructor(alphabetStr) {
        this.alphabet = alphabetStr.toUpperCase().split('');
        if (new Set(this.alphabet).size !== this.alphabet.length) {
          throw new Error("Alphabet has duplicates");
        }
        this.N = this.alphabet.length;
        this.charToIndex = new Map();
        for (let i = 0; i < this.N; i++) {
          this.charToIndex.set(this.alphabet[i], i);
        }
      }

      validateText(text) {
        for (const char of text) {
          if (!this.charToIndex.has(char)) {
            throw new Error(`Invalid char: '${char}'`);
          }
        }
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ —Ä–æ—Ç–æ—Ä–∞ –∫–∞–∫ –ø–æ–ª–Ω–æ–π –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏
      buildRotorFromSubkey(subkey) {
        const keyIndices = subkey.map(c => this.charToIndex.get(c));
        if (keyIndices.some(v => v === undefined)) {
          throw new Error("Invalid subkey");
        }
        // –°–æ–∑–¥–∞—ë–º –º–∞—Å—Å–∏–≤ [0,1,2,...,N-1]
        let rotor = Array.from({length: this.N}, (_, i) => i);
        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ subkey
        let seed = 0;
        for (let c of keyIndices) {
          seed = (seed * 31 + c) & 0x7FFFFFFF;
        }
        // Fisher-Yates shuffle
        for (let i = this.N - 1; i > 0; i--) {
          seed = (seed * 1664525 + 1013904223) & 0x7FFFFFFF;
          const j = Math.floor((seed / 0x80000000) * (i + 1));
          [rotor[i], rotor[j]] = [rotor[j], rotor[i]];
        }
        return rotor;
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 10 —Ä–æ—Ç–æ—Ä–æ–≤
      buildRotors(key) {
        const keyArr = Array.from(key);
        const rotors = [];
        for (let r = 0; r < 10; r++) {
          // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –ø–æ–¥–∫–ª—é—á –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ—Ç–æ—Ä–∞
          const subkey = [];
          for (let i = 0; i < keyArr.length || i < 5; i++) {
            subkey.push(keyArr[(r * 7 + i) % keyArr.length]);
          }
          rotors.push(this.buildRotorFromSubkey(subkey));
        }
        return rotors;
      }

      // –ü—Ä—è–º–æ–π –ø—Ä–æ—Ö–æ–¥ —á–µ—Ä–µ–∑ —Ä–æ—Ç–æ—Ä —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º
      forwardThroughRotor(input, rotor, ringOffset) {
        // –í—Ö–æ–¥ —Å —É—á—ë—Ç–æ–º –ø–æ–≤–æ—Ä–æ—Ç–∞ —Ä–æ—Ç–æ—Ä–∞
        const rotatedInput = (input + ringOffset) % this.N;
        const output = rotor[rotatedInput];
        // –í—ã—Ö–æ–¥ –±–µ–∑ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞ (–∫–∞–∫ –≤ Enigma)
        return output;
      }

      // –û–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ —á–µ—Ä–µ–∑ —Ä–æ—Ç–æ—Ä
      backwardThroughRotor(input, rotor, ringOffset) {
        // –ù–∞–π—Ç–∏, –∫–∞–∫–æ–π –≤—Ö–æ–¥ –¥–∞—ë—Ç —Ç–∞–∫–æ–π –≤—ã—Ö–æ–¥
        const rotatedOutput = input;
        const inputPos = rotor.indexOf(rotatedOutput);
        // –£—á–µ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ
        return (inputPos - ringOffset + this.N) % this.N;
      }

      encrypt(plaintext, key) {
        plaintext = plaintext.toUpperCase();
        key = key.toUpperCase();
        this.validateText(plaintext);
        this.validateText(key);

        const rotors = this.buildRotors(key);
        let ciphertext = '';

        // –ù–∞—á–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —Ä–æ—Ç–æ—Ä–æ–≤ (–≤—Å–µ 0)
        let ringOffsets = new Array(10).fill(0);

        for (let pos = 0; pos < plaintext.length; pos++) {
          // –®–∞–≥ —Ä–æ—Ç–æ—Ä–æ–≤: –ø–µ—Ä–≤—ã–π –≤—Å–µ–≥–¥–∞ —à–∞–≥–∞–µ—Ç, –æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äî –ø–æ —É—Å–ª–æ–≤–∏—é
          ringOffsets[0] = (ringOffsets[0] + 1) % this.N;
          for (let r = 0; r < 9; r++) {
            if (ringOffsets[r] === 0) { // –µ—Å–ª–∏ —Å–¥–µ–ª–∞–ª –æ–±–æ—Ä–æ—Ç
              ringOffsets[r + 1] = (ringOffsets[r + 1] + 1) % this.N;
            } else {
              break;
            }
          }

          let signal = this.charToIndex.get(plaintext[pos]);

          // –ü—Ä–æ—Ö–æ–¥ –í–ü–ï–†–Å–î —á–µ—Ä–µ–∑ –≤—Å–µ 10 —Ä–æ—Ç–æ—Ä–æ–≤
          for (let r = 0; r < 10; r++) {
            signal = this.forwardThroughRotor(signal, rotors[r], ringOffsets[r]);
          }

          ciphertext += this.alphabet[signal];
        }

        this.lastRotors = rotors;
        return ciphertext;
      }

      decrypt(ciphertext, key) {
        key = key.toUpperCase();
        for (const c of ciphertext) {
          if (!this.charToIndex.has(c)) {
            throw new Error(`Invalid ciphertext char: '${c}'`);
          }
        }
        this.validateText(key);

        const rotors = this.buildRotors(key);
        let plaintext = '';

        let ringOffsets = new Array(10).fill(0);

        for (let pos = 0; pos < ciphertext.length; pos++) {
          ringOffsets[0] = (ringOffsets[0] + 1) % this.N;
          for (let r = 0; r < 9; r++) {
            if (ringOffsets[r] === 0) {
              ringOffsets[r + 1] = (ringOffsets[r + 1] + 1) % this.N;
            } else {
              break;
            }
          }

          let signal = this.charToIndex.get(ciphertext[pos]);

          // –ü—Ä–æ—Ö–æ–¥ –ù–ê–ó–ê–î —á–µ—Ä–µ–∑ —Ä–æ—Ç–æ—Ä—ã (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)
          for (let r = 9; r >= 0; r--) {
            signal = this.backwardThroughRotor(signal, rotors[r], ringOffsets[r]);
          }

          plaintext += this.alphabet[signal];
        }

        return plaintext;
      }

      shannonEntropy(text) {
        if (!text) return 0;
        const freq = {};
        for (const c of text) {
          freq[c] = (freq[c] || 0) + 1;
        }
        let entropy = 0;
        const len = text.length;
        for (const count of Object.values(freq)) {
          const p = count / len;
          entropy -= p * Math.log2(p);
        }
        return entropy;
      }

      toHex(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
      }

      toBase64(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        return btoa(String.fromCharCode(...bytes));
      }
    }

    // UI
    const alphabetInput = document.getElementById('alphabet');
    const keyInput = document.getElementById('key');
    const plaintextInput = document.getElementById('plaintext');
    const ciphertextOutput = document.getElementById('ciphertextOutput');
    const encryptBtn = document.getElementById('encryptBtn');
    const decryptBtn = document.getElementById('decryptBtn');
    const copyBtn = document.getElementById('copyBtn');
    const errorDiv = document.getElementById('error');
    const alphabetInfo = document.getElementById('alphabetInfo');
    const rotorParams = document.getElementById('rotorParams');
    const lenEl = document.getElementById('len');
    const entropyEl = document.getElementById('entropy');
    const hexEl = document.getElementById('hex');
    const base64El = document.getElementById('base64');

    function showError(msg) {
      errorDiv.textContent = msg;
      setTimeout(() => errorDiv.textContent = '', 5000);
    }

    function updateAlphabetInfo() {
      const alphabet = alphabetInput.value.toUpperCase();
      const unique = [...new Set(alphabet.split(''))].join('');
      alphabetInfo.textContent = `Length: ${alphabet.length} | Unique: ${unique.length}`;
      if (alphabet.length !== unique.length) {
        alphabetInfo.style.color = 'var(--error)';
      } else {
        alphabetInfo.style.color = '#aaa';
      }
    }

    function updateRotorParams() {
      const alphabet = alphabetInput.value;
      const key = keyInput.value;
      if (!alphabet || !key) {
        rotorParams.innerHTML = 'Enter key to see all 10 rotors';
        return;
      }

      try {
        const machine = new ProfessionalRotorMachine(alphabet);
        const rotors = machine.buildRotors(key);
        let html = '';
        for (let i = 0; i < 10; i++) {
          const preview = rotors[i].map(idx => machine.alphabet[idx]).join('');
          html += `<div class="rotor-line"><strong>Rotor ${i}:</strong> ${preview}</div>`;
        }
        rotorParams.innerHTML = html;
      } catch (e) {
        rotorParams.innerHTML = '<div style="color:var(--error);">Invalid key/alphabet</div>';
      }
    }

    function updateAnalysis(text) {
      if (!text) {
        lenEl.textContent = '0';
        entropyEl.textContent = '0.00';
        hexEl.textContent = '‚Äî';
        base64El.textContent = '‚Äî';
        return;
      }

      try {
        const cipher = new ProfessionalRotorMachine(alphabetInput.value);
        lenEl.textContent = text.length;
        entropyEl.textContent = cipher.shannonEntropy(text).toFixed(2);
        hexEl.textContent = cipher.toHex(text);
        base64El.textContent = cipher.toBase64(text);
      } catch (e) {
        hexEl.textContent = '‚Äî';
        base64El.textContent = '‚Äî';
      }
    }

    function encryptAction() {
      try {
        const cipher = new ProfessionalRotorMachine(alphabetInput.value);
        const result = cipher.encrypt(plaintextInput.value, keyInput.value);
        ciphertextOutput.textContent = result;
        updateAnalysis(result);
      } catch (e) {
        showError(e.message);
        ciphertextOutput.textContent = '[Error]';
        updateAnalysis('');
      }
    }

    function decryptAction() {
      try {
        const cipher = new ProfessionalRotorMachine(alphabetInput.value);
        const result = cipher.decrypt(plaintextInput.value, keyInput.value);
        ciphertextOutput.textContent = result;
        updateAnalysis(result);
      } catch (e) {
        showError(e.message);
        ciphertextOutput.textContent = '[Error]';
        updateAnalysis('');
      }
    }

    alphabetInput.addEventListener('input', () => {
      updateAlphabetInfo();
      updateRotorParams();
    });
    keyInput.addEventListener('input', updateRotorParams);
    encryptBtn.addEventListener('click', encryptAction);
    decryptBtn.addEventListener('click', decryptAction);
    copyBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(ciphertextOutput.textContent)
        .then(() => {}, () => showError("Failed to copy"));
    });

    updateAlphabetInfo();
    updateRotorParams();
  </script>
</body>
</html>
