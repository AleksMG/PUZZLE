<!DOCTYPE html>
<html>
<head>
    <title>Digital AES-like Cipher</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        textarea, input { width: 300px; }
        button { padding: 10px; }
    </style>
</head>
<body>
    <h2>Digital AES-like Cipher (Text)</h2>

    <label>Текст:</label><br>
    <textarea id="input" rows="4">test</textarea><br>

    <label>Ключ:</label><br>
    <input type="text" id="key" value="secret"><br><br>

    <button onclick="encrypt()">Зашифровать</button>
    <button onclick="decrypt()">Расшифровать</button><br>

    <label>Результат:</label><br>
    <textarea id="output" rows="4" readonly></textarea>

    <script>
        // ==================== ЦИФРОВОЙ АЛФАВИТ ====================
        const CHAR_TO_NUM = {};
        const NUM_TO_CHAR = {};
        const alphabet = '0123456789abcdefghijklmnopqrstuvwxyz';
        for (let i = 0; i < alphabet.length; i++) {
            CHAR_TO_NUM[alphabet[i]] = i;
            NUM_TO_CHAR[i] = alphabet[i];
        }
        const MOD = 36;

        // ==================== S-BOX (36 элементов) ====================
        const S_BOX = [
            16, 3, 22, 27, 2, 29, 14, 31, 8, 35,
            11, 26, 19, 33, 6, 25, 20, 9, 32, 15,
            24, 3, 30, 17, 10, 34, 13, 28, 7, 21,
            1, 18, 23, 4, 12, 0
        ];

        const INV_S_BOX = new Array(36);
        for (let i = 0; i < 36; i++) INV_S_BOX[S_BOX[i]] = i;

        // ==================== КЛЮЧЕВАЯ ГЕНЕРАЦИЯ ====================
        function generateKeyMatrix(key) {
            let keyNums = [];
            for (let char of key) {
                if (CHAR_TO_NUM[char] !== undefined) {
                    keyNums.push(CHAR_TO_NUM[char]);
                }
            }
            // Дополняем ключ до 36 элементов
            while (keyNums.length < 36) {
                keyNums.push(...keyNums);
                if (keyNums.length > 36) keyNums = keyNums.slice(0, 36);
            }
            // Преобразуем в матрицу 6x6
            let matrix = [];
            for (let i = 0; i < 6; i++) {
                matrix.push(keyNums.slice(i*6, i*6+6));
            }
            return matrix;
        }

        // ==================== ОСНОВНЫЕ ОПЕРАЦИИ ====================
        function subBytes(state, inverse = false) {
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    state[i][j] = inverse ? INV_S_BOX[state[i][j]] : S_BOX[state[i][j]];
                }
            }
        }

        function shiftRows(state, inverse = false) {
            for (let i = 0; i < 6; i++) {
                let shift = inverse ? (6 - i) % 6 : i;
                state[i] = [...state[i].slice(shift), ...state[i].slice(0, shift)];
            }
        }

        function addRoundKey(state, roundKey) {
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    state[i][j] = (state[i][j] + roundKey[i][j]) % MOD;
                }
            }
        }

        function invAddRoundKey(state, roundKey) {
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    state[i][j] = (state[i][j] - roundKey[i][j] + MOD) % MOD;
                }
            }
        }

        // ==================== ОБРАБОТКА ТЕКСТА ====================
        function textToBlock(text) {
            let nums = [];
            for (let char of text.toLowerCase()) {
                if (CHAR_TO_NUM[char] !== undefined) {
                    nums.push(CHAR_TO_NUM[char]);
                }
            }
            // Дополняем до 36 символов
            while (nums.length < 36) nums.push(0);
            
            let block = [];
            for (let i = 0; i < 6; i++) {
                block.push(nums.slice(i*6, i*6+6));
            }
            return block;
        }

        function blockToText(block) {
            let text = '';
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    text += NUM_TO_CHAR[block[i][j]];
                }
            }
            return text;
        }

        // ==================== ШИФРОВАНИЕ/ДЕШИФРОВАНИЕ ====================
        function processText(text, key, encrypt = true) {
            const keyMatrix = generateKeyMatrix(key.toLowerCase());
            const state = textToBlock(text.toLowerCase());
            
            if (encrypt) {
                addRoundKey(state, keyMatrix);
                for (let round = 0; round < 4; round++) {
                    subBytes(state);
                    shiftRows(state);
                    addRoundKey(state, keyMatrix);
                }
            } else {
                for (let round = 0; round < 4; round++) {
                    invAddRoundKey(state, keyMatrix);
                    shiftRows(state, true);
                    subBytes(state, true);
                }
                invAddRoundKey(state, keyMatrix);
            }
            
            return blockToText(state);
        }

        function encrypt() {
            const text = document.getElementById('input').value;
            const key = document.getElementById('key').value;
            if (!key) return alert('Need key!');
            document.getElementById('output').value = processText(text, key, true);
        }

        function decrypt() {
            const text = document.getElementById('input').value;
            const key = document.getElementById('key').value;
            if (!key) return alert('Need key!');
            document.getElementById('output').value = processText(text, key, false);
        }
    </script>
</body>
</html>
