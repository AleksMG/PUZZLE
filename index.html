<!DOCTYPE html>
<html>
<head>
    <title>AES-like Text Cipher with Coordinates</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        textarea, input { width: 300px; }
        button { padding: 10px; }
    </style>
</head>
<body>
    <h2>AES-like Text Cipher (Coordinate-based)</h2>

    <label>Текст:</label><br>
    <textarea id="input" rows="4">test123</textarea><br>

    <label>Ключ:</label><br>
    <input type="text" id="key" value="secret"><br><br>

    <button onclick="encrypt()">Зашифровать</button>
    <button onclick="decrypt()">Расшифровать</button><br>

    <label>Результат:</label><br>
    <textarea id="output" rows="4" readonly></textarea>

    <script>
        // ==================== КООРДИНАТНАЯ СИСТЕМА ====================
        const alphabet = '0123456789abcdefghijklmnopqrstuvwxyz';
        
        // Преобразование символа в координаты (row, col)
        function charToCoords(char) {
            const index = alphabet.indexOf(char.toLowerCase());
            if (index === -1) return null;
            return {
                row: Math.floor(index / 6),
                col: index % 6
            };
        }

        // Преобразование координат в символ
        function coordsToChar(coords) {
            const index = coords.row * 6 + coords.col;
            return alphabet[index];
        }

        // ==================== S-BOX ДЛЯ КООРДИНАТ ====================
        // S-BOX: (row, col) -> (new_row, new_col)
        const S_BOX = [
            /* row 0 */ [{row:1, col:1}, {row:0, col:3}, {row:2, col:2}, {row:3, col:3}, {row:0, col:2}, {row:3, col:5}],
            /* row 1 */ [{row:1, col:4}, {row:2, col:1}, {row:0, col:1}, {row:3, col:2}, {row:1, col:0}, {row:4, col:5}],
            /* row 2 */ [{row:5, col:0}, {row:4, col:3}, {row:3, col:1}, {row:2, col:5}, {row:1, col:3}, {row:5, col:4}],
            /* row 3 */ [{row:2, col:0}, {row:5, col:2}, {row:4, col:1}, {row:0, col:5}, {row:3, col:4}, {row:1, col:5}],
            /* row 4 */ [{row:0, col:4}, {row:3, col:0}, {row:5, col:1}, {row:4, col:4}, {row:2, col:4}, {row:4, col:2}],
            /* row 5 */ [{row:4, col:0}, {row:1, col:2}, {row:5, col:3}, {row:2, col:3}, {row:5, col:5}, {row:0, col:0}]
        ];

        // Обратный S-BOX
        const INV_S_BOX = [];
        for (let row = 0; row < 6; row++) {
            INV_S_BOX[row] = [];
            for (let col = 0; col < 6; col++) {
                const transformed = S_BOX[row][col];
                INV_S_BOX[transformed.row][transformed.col] = {row, col};
            }
        }

        // ==================== КЛЮЧЕВАЯ ГЕНЕРАЦИЯ ====================
        function generateKeyCoords(key) {
            const keyCoords = [];
            for (let char of key.toLowerCase()) {
                const coords = charToCoords(char);
                if (coords) keyCoords.push(coords);
            }
            return keyCoords;
        }

        // ==================== ОСНОВНЫЕ ОПЕРАЦИИ ====================
        function subBytes(coords, inverse = false) {
            const box = inverse ? INV_S_BOX : S_BOX;
            return box[coords.row][coords.col];
        }

        function shiftRows(coords, inverse = false) {
            const shift = inverse ? (6 - coords.row) % 6 : coords.row;
            return {
                row: coords.row,
                col: (coords.col + shift) % 6
            };
        }

        function mixColumns(coords, inverse = false) {
            // Простое перемешивание: (row + col * 2) mod 6 для row, (col + row) mod 6 для col
            if (inverse) {
                return {
                    row: (coords.row - coords.col * 2 + 12) % 6,
                    col: (coords.col - coords.row + 6) % 6
                };
            }
            return {
                row: (coords.row + coords.col * 2) % 6,
                col: (coords.col + coords.row) % 6
            };
        }

        function addRoundKey(coords, keyCoords, keyIndex) {
            const key = keyCoords[keyIndex % keyCoords.length];
            return {
                row: (coords.row + key.row) % 6,
                col: (coords.col + key.col) % 6
            };
        }

        function invAddRoundKey(coords, keyCoords, keyIndex) {
            const key = keyCoords[keyIndex % keyCoords.length];
            return {
                row: (coords.row - key.row + 6) % 6,
                col: (coords.col - key.col + 6) % 6
            };
        }

        // ==================== ОБРАБОТКА ТЕКСТА ====================
        function processText(text, key, encrypt = true) {
            const keyCoords = generateKeyCoords(key);
            if (keyCoords.length === 0) return '';

            let result = '';
            let keyIndex = 0;

            for (let char of text) {
                let coords = charToCoords(char);
                if (!coords) {
                    result += char;
                    continue;
                }

                if (encrypt) {
                    // ШИФРОВАНИЕ: 4 раунда
                    for (let round = 0; round < 4; round++) {
                        coords = subBytes(coords);
                        coords = shiftRows(coords);
                        coords = mixColumns(coords);
                        coords = addRoundKey(coords, keyCoords, keyIndex++);
                    }
                } else {
                    // ДЕШИФРОВКА: обратные раунды
                    for (let round = 0; round < 4; round++) {
                        coords = invAddRoundKey(coords, keyCoords, --keyIndex);
                        coords = mixColumns(coords, true);
                        coords = shiftRows(coords, true);
                        coords = subBytes(coords, true);
                    }
                }

                result += coordsToChar(coords);
            }

            return result;
        }

        function encrypt() {
            const text = document.getElementById('input').value;
            const key = document.getElementById('key').value;
            document.getElementById('output').value = processText(text, key, true);
        }

        function decrypt() {
            const text = document.getElementById('input').value;
            const key = document.getElementById('key').value;
            document.getElementById('output').value = processText(text, key, false);
        }
    </script>
</body>
</html>
