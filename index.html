<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CipherOS | Professional Rotor Machine</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --bg: #0f0f1b;
      --card: #1a1a2e;
      --input: #16213e;
      --text: #e6e6ff;
      --muted: #8a8ab8;
      --primary: #4cc9f0;
      --success: #4ade80;
      --warning: #facc15;
      --danger: #f87171;
      --border: #2d2d44;
      --radius: 12px;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }

    body {
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      display: grid;
      gap: 24px;
    }

    .header {
      text-align: center;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    h1 {
      font-size: 28px;
      margin-bottom: 6px;
      background: linear-gradient(90deg, var(--primary), #a29bff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 24px;
      border: 1px solid var(--border);
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .grid-2 { grid-template-columns: 1fr; }
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    input[type="text"], textarea {
      width: 100%;
      padding: 12px 16px;
      background: var(--input);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-family: monospace;
      font-size: 15px;
      margin-bottom: 16px;
    }

    input[type="checkbox"] {
      margin-right: 8px;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button:hover { opacity: 0.9; }
    .btn-encrypt { background: var(--primary); color: #0f0f1b; }
    .btn-decrypt { background: var(--success); color: #0f0f1b; }
    .btn-reset   { background: var(--input); color: var(--text); }
    .btn-copy    { background: var(--warning); color: #0f0f1b; }

    .output-section {
      margin-top: 12px;
    }

    .output-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .output {
      background: var(--input);
      padding: 16px;
      border-radius: 8px;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
      min-height: 60px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    .stat-box {
      background: var(--input);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--primary);
    }

    .stat-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .rotor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }

    .rotor-card {
      background: var(--input);
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
    }

    .rotor-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .rotor-step.pos { color: var(--success); }
    .rotor-step.neg { color: var(--danger); }
    .rotor-step.zero { color: var(--muted); }

    .status {
      padding: 10px;
      border-radius: 8px;
      margin-top: 12px;
      font-size: 14px;
      display: none;
    }
    .status.show { display: block; }
    .status.ok { background: rgba(76, 201, 240, 0.15); color: var(--primary); }
    .status.warn { background: rgba(250, 204, 21, 0.15); color: var(--warning); }

    .form-hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1><i class="fas fa-lock"></i> CipherOS Rotor Machine</h1>
      <p class="subtitle">Military-grade 10-rotor cipher with nonlinear avalanche diffusion.</p>
    </div>

    <!-- Configuration -->
    <div class="card">
      <div class="grid-2">
        <div>
          <label for="alphabet">Alphabet (unique uppercase letters)</label>
          <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ" spellcheck="false">
        </div>
        <div>
          <label for="key">Key (any characters — only alphabet chars used)</label>
          <input type="text" id="key" value="TOP_SECRET_2026!" spellcheck="false">
        </div>
      </div>

      <label for="input">Input Text</label>
      <textarea id="input" spellcheck="false">HELLO WORLD! This is a test message with numbers 123 and symbols @#$.</textarea>

      <div class="form-group">
        <label class="form-label">
          <input type="checkbox" id="diffusionMode" checked>
          Enable Diffusion (Avalanche Effect)
        </label>
        <div class="form-hint">When enabled, ciphertext errors propagate to all subsequent characters using nonlinear rotor groups.</div>
      </div>

      <div class="btn-group">
        <button class="btn-encrypt" id="encrypt"><i class="fas fa-lock"></i> Encrypt</button>
        <button class="btn-decrypt" id="decrypt"><i class="fas fa-unlock"></i> Decrypt</button>
        <button class="btn-reset" id="reset"><i class="fas fa-undo"></i> Reset</button>
      </div>

      <div id="status" class="status"></div>
    </div>

    <!-- Output & Analysis -->
    <div class="card">
      <div class="output-section">
        <div class="output-label">
          <span>Result</span>
          <button class="btn-copy" id="copy" style="padding:6px 12px;font-size:12px;"><i class="far fa-copy"></i> Copy</button>
        </div>
        <div class="output" id="output">Result will appear here after encryption or decryption.</div>
      </div>

      <div class="stats-grid">
        <div class="stat-box">
          <div class="stat-value" id="lengthStat">0</div>
          <div class="stat-label">Length</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="entropyStat">0.00</div>
          <div class="stat-label">Entropy</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="uniqueStat">0</div>
          <div class="stat-label">Unique Chars</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="modeStat">Avalanche</div>
          <div class="stat-label">Mode</div>
        </div>
      </div>
    </div>

    <!-- Rotor Visualization -->
    <div class="card">
      <label>Active Rotors (steps per rotor)</label>
      <div class="rotor-grid" id="rotorGrid">
        <div style="color:var(--muted);">Rotors will appear after key is set</div>
      </div>
    </div>
  </div>

  <script>
    // ==============================
    // ИСПРАВЛЕННАЯ КРИПТОСИСТЕМА С НЕЛИНЕЙНОЙ АВАЛАНЧЕЙ
    // ==============================

    class RotorMachine {
      constructor(alphabet) {
        const clean = alphabet.toUpperCase().replace(/[^A-Z]/g, '');
        const unique = [...new Set(clean)].join('');
        if (unique.length < 2) throw new Error("Alphabet too short");
        this.alphabet = unique.split('');
        this.N = this.alphabet.length;
        this.charToIndex = new Map();
        this.alphabet.forEach((ch, i) => this.charToIndex.set(ch, i));
      }

      filter(text) {
        return text.toUpperCase().split('').filter(c => this.charToIndex.has(c)).join('');
      }

      buildRotorsAndSteps(key) {
        const keyClean = this.filter(key);
        if (!keyClean) throw new Error("Key has no valid characters");
        const rotors = [], steps = [];

        for (let r = 0; r < 10; r++) {
          let seed = r;
          for (let i = 0; i < Math.max(5, keyClean.length); i++) {
            const ch = keyClean[(r * 7 + i) % keyClean.length];
            seed = (seed * 31 + this.charToIndex.get(ch)) & 0x7FFFFFFF;
          }

          let rotor = Array.from({length: this.N}, (_, i) => i);
          for (let i = this.N - 1; i > 0; i--) {
            seed = (seed * 1664525 + 1013904223) & 0x7FFFFFFF;
            const j = Math.floor((seed / 0x80000000) * (i + 1));
            [rotor[i], rotor[j]] = [rotor[j], rotor[i]];
          }
          rotors.push(rotor);
          steps.push((seed % 101) - 50);
        }
        return { rotors, steps };
      }

      getKeyParams(key) {
        const keyClean = this.filter(key);
        const indices = keyClean.split('').map(c => this.charToIndex.get(c));
        const params = [];
        for (let i = 0; i < 10; i++) {
          let sum = 0;
          for (let j = 0; j < indices.length; j++) {
            sum = (sum + indices[j] * (i + j + 1)) & 0x7FFFFFFF;
          }
          params.push(sum % this.N);
        }
        return params;
      }

      // ПОЗИЦИОННОЕ ОБНОВЛЕНИЕ (без диффузии)
      updatePositions(positions, keyParams, steps, position) {
        const count = (keyParams[0] + position) % 10 + 1;
        const start = (keyParams[1] + position) % 10;
        for (let i = 0; i < count; i++) {
          const rotorIndex = (start + i) % 10;
          positions[rotorIndex] = ((positions[rotorIndex] + steps[rotorIndex]) % this.N + this.N) % this.N;
        }
      }

      // НЕЛИНЕЙНОЕ ОБНОВЛЕНИЕ ЧЕРЕЗ FEEDBACK (с диффузией)
      updateWithFeedback(positions, keyParams, steps, feedbackValue) {
        const count = (keyParams[0] + feedbackValue) % 10 + 1;
        const start = (keyParams[1] + feedbackValue) % 10;
        for (let i = 0; i < count; i++) {
          const rotorIndex = (start + i) % 10;
          positions[rotorIndex] = ((positions[rotorIndex] + steps[rotorIndex]) % this.N + this.N) % this.N;
        }
      }

      forward(sig, rotor, off) {
        const inRot = (sig + off) % this.N;
        return (rotor[inRot] - off + this.N) % this.N;
      }

      backward(sig, rotor, off) {
        const outRot = (sig + off) % this.N;
        const inPos = rotor.indexOf(outRot);
        return (inPos - off + this.N) % this.N;
      }

      encrypt(plaintext, key, useDiffusion = false) {
        const clean = this.filter(plaintext);
        if (!clean) return "";
        const { rotors, steps } = this.buildRotorsAndSteps(key);
        const keyParams = this.getKeyParams(key);
        let pos = new Array(10).fill(0);
        let out = "";

        for (let i = 0; i < clean.length; i++) {
          if (!useDiffusion) {
            this.updatePositions(pos, keyParams, steps, i);
          }

          let signal = this.charToIndex.get(clean[i]);
          for (let r = 0; r < 10; r++) {
            signal = this.forward(signal, rotors[r], pos[r]);
          }
          const cipherChar = this.alphabet[signal];
          out += cipherChar;

          if (useDiffusion) {
            this.updateWithFeedback(pos, keyParams, steps, signal);
          }
        }
        return out;
      }

      decrypt(ciphertext, key, useDiffusion = false) {
        const clean = this.filter(ciphertext);
        if (!clean) return "";
        const { rotors, steps } = this.buildRotorsAndSteps(key);
        const keyParams = this.getKeyParams(key);
        let pos = new Array(10).fill(0);
        let out = "";

        for (let i = 0; i < clean.length; i++) {
          if (!useDiffusion) {
            this.updatePositions(pos, keyParams, steps, i);
          }

          let signal = this.charToIndex.get(clean[i]);
          for (let r = 9; r >= 0; r--) {
            signal = this.backward(signal, rotors[r], pos[r]);
          }
          const plainChar = this.alphabet[signal];
          out += plainChar;

          if (useDiffusion) {
            const cipherSignal = this.charToIndex.get(clean[i]);
            this.updateWithFeedback(pos, keyParams, steps, cipherSignal);
          }
        }
        return out;
      }

      entropy(text) {
        if (!text) return 0;
        const freq = {};
        for (const c of text) freq[c] = (freq[c] || 0) + 1;
        let e = 0;
        for (const p of Object.values(freq)) {
          const prob = p / text.length;
          e -= prob * Math.log2(prob);
        }
        return e;
      }
    }

    // ==============================
    // UI
    // ==============================

    class App {
      constructor() {
        this.init();
      }

      init() {
        this.bindElements();
        this.bindEvents();
        this.updateAll();
      }

      bindElements() {
        this.alphabet = document.getElementById('alphabet');
        this.key = document.getElementById('key');
        this.input = document.getElementById('input');
        this.output = document.getElementById('output');
        this.rotorGrid = document.getElementById('rotorGrid');
        this.status = document.getElementById('status');
        this.diffusionMode = document.getElementById('diffusionMode');

        // Stats
        this.lenStat = document.getElementById('lengthStat');
        this.entStat = document.getElementById('entropyStat');
        this.uniStat = document.getElementById('uniqueStat');
        this.modeStat = document.getElementById('modeStat');
      }

      bindEvents() {
        document.getElementById('encrypt').addEventListener('click', () => this.run('encrypt'));
        document.getElementById('decrypt').addEventListener('click', () => this.run('decrypt'));
        document.getElementById('reset').addEventListener('click', () => this.reset());
        document.getElementById('copy').addEventListener('click', () => this.copy());

        this.alphabet.addEventListener('input', () => this.updateAll());
        this.key.addEventListener('input', () => this.updateAll());
        this.diffusionMode.addEventListener('change', () => this.updateModeLabel());
      }

      async run(mode) {
        const useDiffusion = this.diffusionMode.checked;
        try {
          const machine = new RotorMachine(this.alphabet.value);
          const result = mode === 'encrypt'
            ? machine.encrypt(this.input.value, this.key.value, useDiffusion)
            : machine.decrypt(this.input.value, this.key.value, useDiffusion);

          this.output.textContent = result || '(empty)';
          this.updateAnalysis(result);
          this.showMessage(`${mode === 'encrypt' ? 'Encrypted' : 'Decrypted'} successfully`, 'ok');
          this.updateRotorDisplay(machine);
          this.updateModeLabel();
        } catch (e) {
          this.output.textContent = '';
          this.updateAnalysis('');
          this.showMessage(`Error: ${e.message}`, 'warn');
        }
      }

      reset() {
        this.input.value = 'HELLO WORLD! This is a test message with numbers 123 and symbols @#$.';
        this.output.textContent = 'Result will appear here after encryption or decryption.';
        this.updateAnalysis('');
        this.showMessage('Reset complete', 'ok');
      }

      copy() {
        const text = this.output.textContent.trim();
        if (!text || text === '(empty)' || text.includes('Result will appear')) {
          this.showMessage('Nothing to copy', 'warn');
          return;
        }
        if (navigator.clipboard) {
          navigator.clipboard.writeText(text).then(() => {
            this.showMessage('Copied to clipboard', 'ok');
          }).catch(() => this.fallbackCopy(text));
        } else {
          this.fallbackCopy(text);
        }
      }

      fallbackCopy(text) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand('copy');
          this.showMessage('Copied (legacy)', 'ok');
        } catch (e) {
          this.showMessage('Copy failed', 'warn');
        }
        document.body.removeChild(ta);
      }

      updateAnalysis(text) {
        const machine = new RotorMachine(this.alphabet.value);
        this.lenStat.textContent = text.length;
        this.entStat.textContent = text ? machine.entropy(text).toFixed(2) : '0.00';
        this.uniStat.textContent = text ? new Set(text).size : '0';
      }

      updateAll() {
        try {
          const machine = new RotorMachine(this.alphabet.value);
          this.updateRotorDisplay(machine);
          this.updateModeLabel();
        } catch (e) {
          this.rotorGrid.innerHTML = `<div style="color:var(--warning);">${e.message}</div>`;
        }
      }

      updateRotorDisplay(machine) {
        try {
          const { rotors, steps } = machine.buildRotorsAndSteps(this.key.value);
          this.rotorGrid.innerHTML = '';
          steps.forEach((step, i) => {
            const div = document.createElement('div');
            div.className = 'rotor-card';
            const cls = step > 0 ? 'pos' : (step < 0 ? 'neg' : 'zero');
            const sign = step > 0 ? '+' : '';
            div.innerHTML = `
              <div class="rotor-header">
                <span>Rotor ${i+1}</span>
                <span class="rotor-step ${cls}">${sign}${step}</span>
              </div>
            `;
            this.rotorGrid.appendChild(div);
          });
        } catch (e) {
          this.rotorGrid.innerHTML = `<div style="color:var(--warning);">Set valid key</div>`;
        }
      }

      updateModeLabel() {
        const mode = this.diffusionMode.checked ? 'Avalanche' : 'Positional';
        this.modeStat.textContent = mode;
      }

      showMessage(text, type) {
        this.status.textContent = text;
        this.status.className = `status show ${type}`;
        setTimeout(() => {
          this.status.classList.remove('show');
        }, 3000);
      }
    }

    document.addEventListener('DOMContentLoaded', () => new App());
  </script>
</body>
</html>

